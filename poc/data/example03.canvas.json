{
  "dataNodes": [
    {
      "id": "T8-bTaZZQOm3w7a8AKyykA",
      "indecies": [
        {
          "id": "plc-elementalmediaconvert-usd-20181220175545",
          "shards": [
            {
              "id": "0",
              "name": "[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]"
            },
            {
              "id": "2",
              "name": "[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]"
            },
            {
              "id": "4",
              "name": "[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]"
            }
          ]
        },
        {
          "id": "plc-elementalmediaconvert-usd-20190307172051",
          "shards": [
            {
              "id": "2",
              "name": "[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]"
            },
            {
              "id": "3",
              "name": "[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]"
            },
            {
              "id": "4",
              "name": "[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]"
            }
          ]
        },
        {
          "id": "plc-elementalmediaconvert-usd-20190320213240",
          "shards": [
            {
              "id": "0",
              "name": "[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]"
            },
            {
              "id": "4",
              "name": "[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]"
            }
          ]
        }
      ]
    },
    {
      "id": "V1Lm6aKHQ8mO2J-ujky32A",
      "indecies": [
        {
          "id": "plc-elementalmediaconvert-usd-20181220175545",
          "shards": [
            {
              "id": "1",
              "name": "[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]"
            },
            {
              "id": "3",
              "name": "[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]"
            }
          ]
        },
        {
          "id": "plc-elementalmediaconvert-usd-20190307172051",
          "shards": [
            {
              "id": "1",
              "name": "[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]"
            }
          ]
        },
        {
          "id": "plc-elementalmediaconvert-usd-20190320213240",
          "shards": [
            {
              "id": "1",
              "name": "[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]"
            },
            {
              "id": "2",
              "name": "[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]"
            },
            {
              "id": "3",
              "name": "[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]"
            }
          ]
        }
      ]
    }
  ],
  "detailedRootNode": {
    "type": "RootNode",
    "nodeId": "detailedRootNode",
    "properties": [],
    "children": [
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-searches",
            "absTime": 1088400,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-searches-search",
                "type": "SearchNode",
                "absTime": 1088400,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 450707,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 38545,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 326415,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 75544,
                        "count": 14,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 10173,
                        "count": 13,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 402032,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 29216,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 319689,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 53110,
                            "count": 14,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 25691,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 2552,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 16584,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 6543,
                                "count": 8,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 25691,
                            "cost": 0.0006334664900886942
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 15304,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 1916,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 8294,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 5083,
                                "count": 7,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 15304,
                            "cost": 0.0003773528147723863
                          }
                        ],
                        "relTime": 361037,
                        "cost": 0.00890213853809318
                      }
                    ],
                    "relTime": 48675,
                    "cost": 0.0012001861120652052
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 269425,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 242239,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 38274,
                            "properties": [],
                            "children": [],
                            "relTime": 38274,
                            "cost": 0.0009437272368399316
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 123756,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 123756,
                            "cost": 0.003051468566712718
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 80209,
                        "cost": 0.0019777242498744334
                      }
                    ],
                    "relTime": 27186,
                    "cost": 0.0006703289089389763
                  }
                ],
                "relTime": 368268,
                "cost": 0.009080434291074043
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-aggrs",
            "absTime": 1907738,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 1907738,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 29514,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 51084,
                    "count": 13,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 1827125,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 730496,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 5631,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 284088,
                        "count": 13,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 440759,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 730496,
                    "cost": 0.018011939478565674
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][0]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 946218,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 3367,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 903219,
                        "count": 13,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 39614,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 946218,
                    "cost": 0.023331026247275077
                  }
                ],
                "relTime": 231024,
                "cost": 0.00569639026920908
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 2996138,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-searches",
            "absTime": 867832,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-searches-search",
                "type": "SearchNode",
                "absTime": 867832,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 255613,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 49286,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 100243,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 93333,
                        "count": 15,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 12719,
                        "count": 14,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 200624,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 34806,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 94528,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 71272,
                            "count": 15,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 23709,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 3734,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 14079,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 5884,
                                "count": 8,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 23709,
                            "cost": 0.0005845960458336713
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 33481,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 2058,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 8379,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 23032,
                                "count": 8,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 33481,
                            "cost": 0.0008255455822918364
                          }
                        ],
                        "relTime": 143434,
                        "cost": 0.0035366716959005784
                      }
                    ],
                    "relTime": 54989,
                    "cost": 0.0013558712710088048
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 536167,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 508341,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 42049,
                            "properties": [],
                            "children": [],
                            "relTime": 42049,
                            "cost": 0.0010368079265789382
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 436425,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 436425,
                            "cost": 0.010760990733601587
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 29867,
                        "cost": 0.000736434691505937
                      }
                    ],
                    "relTime": 27826,
                    "cost": 0.0006861094762059867
                  }
                ],
                "relTime": 76052,
                "cost": 0.00187522453404793
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-aggrs",
            "absTime": 3274744,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 3274744,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 23057,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 49179,
                    "count": 14,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 3202492,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 456108,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 4199,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 376039,
                        "count": 14,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 75851,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 456108,
                    "cost": 0.01124631714847122
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][2]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 2579065,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 1908,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 2535941,
                        "count": 14,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 41197,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 2579065,
                    "cost": 0.06359235737264404
                  }
                ],
                "relTime": 239571,
                "cost": 0.005907134813632734
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 4142576,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-searches",
            "absTime": 730296,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-searches-search",
                "type": "SearchNode",
                "absTime": 730296,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 272127,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 35088,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 130841,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 95359,
                        "count": 15,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 10807,
                        "count": 14,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 223703,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 26473,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 124031,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 73181,
                            "count": 15,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 22572,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 2491,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 11913,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 8154,
                                "count": 10,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 22572,
                            "cost": 0.0005565608817983731
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 12391,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 1570,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 6634,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 4177,
                                "count": 6,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 12391,
                            "cost": 0.00030552657657113424
                          }
                        ],
                        "relTime": 188740,
                        "cost": 0.0046537879155867865
                      }
                    ],
                    "relTime": 48424,
                    "cost": 0.0011939971708401747
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 275749,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 248989,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 42050,
                            "properties": [],
                            "children": [],
                            "relTime": 42050,
                            "cost": 0.001036832583715293
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 162372,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 162372,
                            "cost": 0.004003628544185958
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 44567,
                        "cost": 0.0010988945959200824
                      }
                    ],
                    "relTime": 26760,
                    "cost": 0.0006598249688518725
                  }
                ],
                "relTime": 182420,
                "cost": 0.004497954813825059
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-aggrs",
            "absTime": 3697924,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 3697924,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 41118,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 47310,
                    "count": 14,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 3609480,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 467480,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 5055,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 393678,
                        "count": 14,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 68728,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 467480,
                    "cost": 0.011526718103096911
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20181220175545][4]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 2964052,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 11641,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 2915177,
                        "count": 14,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 37215,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 2964052,
                    "cost": 0.07308503432643237
                  }
                ],
                "relTime": 266392,
                "cost": 0.0065684638678022425
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 4428220,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-searches",
            "absTime": 1278837,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-searches-search",
                "type": "SearchNode",
                "absTime": 1278837,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 1028095,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 54792,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 921164,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 46149,
                        "count": 10,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 5968,
                        "count": 9,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 990197,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 41533,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 914528,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 34123,
                            "count": 10,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 26519,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 6249,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 16394,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 3867,
                                "count": 5,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 26519,
                            "cost": 0.0006538825989903889
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 13722,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 2058,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 7715,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 3939,
                                "count": 6,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 13722,
                            "cost": 0.00033834522505924494
                          }
                        ],
                        "relTime": 949956,
                        "cost": 0.023423194622968962
                      }
                    ],
                    "relTime": 37898,
                    "cost": 0.0009344561535705629
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 212389,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 193482,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 25838,
                            "properties": [],
                            "children": [],
                            "relTime": 25838,
                            "cost": 0.0006370910891328357
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 140469,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 140469,
                            "cost": 0.003463563286608882
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 27175,
                        "cost": 0.0006700576804390746
                      }
                    ],
                    "relTime": 18907,
                    "cost": 0.0004661924770583839
                  }
                ],
                "relTime": 38353,
                "cost": 0.0009456751506119531
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-aggrs",
            "absTime": 1122774,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 1122774,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 60385,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 37875,
                    "count": 9,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 1024503,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 298450,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 8556,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 228089,
                        "count": 9,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 61791,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 298450,
                    "cost": 0.007358922345061336
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][2]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 626036,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 4147,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 594465,
                        "count": 9,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 27410,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 626036,
                    "cost": 0.015436255014953321
                  }
                ],
                "relTime": 198288,
                "cost": 0.004889214253501499
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 2401611,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-searches",
            "absTime": 1120877,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-searches-search",
                "type": "SearchNode",
                "absTime": 1120877,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 262938,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 52033,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 127967,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 73261,
                        "count": 12,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 9651,
                        "count": 11,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 214765,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 38299,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 121729,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 54722,
                            "count": 12,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 25804,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 3983,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 17003,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 4808,
                                "count": 6,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 25804,
                            "cost": 0.0006362527464967757
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 16191,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 2058,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 8099,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 6023,
                                "count": 7,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 16191,
                            "cost": 0.0003992236947190085
                          }
                        ],
                        "relTime": 172770,
                        "cost": 0.0042600134480021675
                      }
                    ],
                    "relTime": 48173,
                    "cost": 0.001187808229615144
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 362732,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 339516,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 37758,
                            "properties": [],
                            "children": [],
                            "relTime": 37758,
                            "cost": 0.0009310041544809044
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 261641,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 261641,
                            "cost": 0.006451317812981045
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 40117,
                        "cost": 0.0009891703391416505
                      }
                    ],
                    "relTime": 23216,
                    "cost": 0.0005724400776108023
                  }
                ],
                "relTime": 495207,
                "cost": 0.012210386522803783
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-aggrs",
            "absTime": 1971916,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 1971916,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 33887,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 82897,
                    "count": 11,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 1855119,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 514833,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 5534,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 417623,
                        "count": 11,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 91660,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 514833,
                    "cost": 0.0126943074809012
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][3]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 1163385,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 3352,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 1117429,
                        "count": 11,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 42588,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 1163385,
                    "cost": 0.02868574257801703
                  }
                ],
                "relTime": 293698,
                "cost": 0.007241751633103783
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 3092793,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-searches",
            "absTime": 1029218,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-searches-search",
                "type": "SearchNode",
                "absTime": 1029218,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 355532,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 38435,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 238601,
                        "count": 4,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 69164,
                        "count": 15,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 9299,
                        "count": 13,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 306558,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 28589,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 226001,
                            "count": 4,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 51948,
                            "count": 15,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 37459,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 2574,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 28601,
                                "count": 6,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 6268,
                                "count": 9,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 37459,
                            "cost": 0.000923631670710848
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 26384,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 1660,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 19329,
                                "count": 6,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 5380,
                                "count": 8,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 26384,
                            "cost": 0.0006505538855825039
                          }
                        ],
                        "relTime": 242715,
                        "cost": 0.005984656850331922
                      }
                    ],
                    "relTime": 48974,
                    "cost": 0.0012075585958352616
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 622118,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 595142,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 35510,
                            "properties": [],
                            "children": [],
                            "relTime": 35510,
                            "cost": 0.0008755749119555304
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 513172,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 513172,
                            "cost": 0.012653351977416035
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 46460,
                        "cost": 0.0011455705550395365
                      }
                    ],
                    "relTime": 26976,
                    "cost": 0.0006651509103044885
                  }
                ],
                "relTime": 51568,
                "cost": 0.0012715192075393633
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-aggrs",
            "absTime": 1453855,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 1453855,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 46306,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 48324,
                    "count": 13,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 1359210,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 419642,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 6090,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 333450,
                        "count": 13,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 80084,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 419642,
                    "cost": 0.010347170014160594
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190307172051][4]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 756070,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 5047,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 714069,
                        "count": 13,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 36936,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 756070,
                    "cost": 0.018642521083700868
                  }
                ],
                "relTime": 278143,
                "cost": 0.006858209877106366
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 2483073,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-searches",
            "absTime": 819997,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-searches-search",
                "type": "SearchNode",
                "absTime": 819997,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 321396,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 47382,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 164198,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 96358,
                        "count": 17,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 13422,
                        "count": 16,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 265785,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 35369,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 157394,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 73002,
                            "count": 17,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 28362,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 3499,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 18230,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 6622,
                                "count": 7,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 28362,
                            "cost": 0.0006993257012921079
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 20595,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 2253,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 9339,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 8988,
                                "count": 11,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 20595,
                            "cost": 0.0005078137232251239
                          }
                        ],
                        "relTime": 216828,
                        "cost": 0.005346357561517706
                      }
                    ],
                    "relTime": 55611,
                    "cost": 0.0013712080098214306
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 394611,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 339946,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 49379,
                            "properties": [],
                            "children": [],
                            "relTime": 49379,
                            "cost": 0.0012175447360589168
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 214228,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 214228,
                            "cost": 0.005282249006995476
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 76339,
                        "cost": 0.00188230113218173
                      }
                    ],
                    "relTime": 54665,
                    "cost": 0.0013478823588298809
                  }
                ],
                "relTime": 103990,
                "cost": 0.0025640956095256437
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-aggrs",
            "absTime": 3401284,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 3401284,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 134395,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 69611,
                    "count": 16,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 3197260,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 441184,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 9780,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 369654,
                        "count": 16,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 61729,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 441184,
                    "cost": 0.010878334045513622
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][0]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 2595910,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 7821,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 2557365,
                        "count": 16,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 30703,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 2595910,
                    "cost": 0.06400770683453903
                  }
                ],
                "relTime": 364190,
                "cost": 0.00897988248901956
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 4221281,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-searches",
            "absTime": 668675,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-searches-search",
                "type": "SearchNode",
                "absTime": 668675,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 348088,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 40881,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 185446,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 108974,
                        "count": 17,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 12751,
                        "count": 16,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 293835,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 30661,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 179365,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 83789,
                            "count": 17,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 27271,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 2790,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 18559,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 5911,
                                "count": 7,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 27271,
                            "cost": 0.0006724247655291261
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 35750,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 1954,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 8431,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 25350,
                                "count": 11,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 35750,
                            "cost": 0.0008814926246806593
                          }
                        ],
                        "relTime": 230814,
                        "cost": 0.005691212270574592
                      }
                    ],
                    "relTime": 54253,
                    "cost": 0.0013377236186517428
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 277838,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 246703,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 47791,
                            "properties": [],
                            "children": [],
                            "relTime": 47791,
                            "cost": 0.0011783892035276472
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 149323,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 149323,
                            "cost": 0.003681877571893429
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 49589,
                        "cost": 0.0012227227346934045
                      }
                    ],
                    "relTime": 31135,
                    "cost": 0.0007676999404037015
                  }
                ],
                "relTime": 42749,
                "cost": 0.001054067922027231
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-aggrs",
            "absTime": 2106669,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 2106669,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 27549,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 73762,
                    "count": 16,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 2005340,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 527519,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 4721,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 425002,
                        "count": 16,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 97775,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 527519,
                    "cost": 0.01300710791269697
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[T8-bTaZZQOm3w7a8AKyykA][plc-elementalmediaconvert-usd-20190320213240][4]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 1270997,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 2468,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 1238990,
                        "count": 16,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 29518,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 1270997,
                    "cost": 0.031339146335419406
                  }
                ],
                "relTime": 308153,
                "cost": 0.007598170539111026
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 2775344,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-searches",
            "absTime": 480717,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-searches-search",
                "type": "SearchNode",
                "absTime": 480717,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 219945,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 40474,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 120919,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 48666,
                        "count": 13,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 9858,
                        "count": 12,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 180363,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 30031,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 114587,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 35729,
                            "count": 13,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 21837,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 2850,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 16397,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 2582,
                                "count": 4,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 21837,
                            "cost": 0.0005384378865776659
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 15787,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 1757,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 8331,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 5685,
                                "count": 10,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 15787,
                            "cost": 0.00038926221163170817
                          }
                        ],
                        "relTime": 142739,
                        "cost": 0.0035195349861340593
                      }
                    ],
                    "relTime": 39582,
                    "cost": 0.0009759787711918841
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 214558,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 182891,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 33356,
                            "properties": [],
                            "children": [],
                            "relTime": 33356,
                            "cost": 0.0008224634402474985
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 858715,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 858715,
                            "cost": 0.021173452844829434
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": -709180,
                        "cost": -0.01748634796002881
                      }
                    ],
                    "relTime": 31667,
                    "cost": 0.0007808175369444038
                  }
                ],
                "relTime": 46214,
                "cost": 0.0011395048994962793
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-aggrs",
            "absTime": 1851036,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 1851036,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 49566,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 53337,
                    "count": 12,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 1748119,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 376599,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 6912,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 317788,
                        "count": 12,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 51882,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 376599,
                    "cost": 0.00928585289404508
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][1]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 1191508,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 3054,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 1147158,
                        "count": 12,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 41279,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 1191508,
                    "cost": 0.029379175223720362
                  }
                ],
                "relTime": 282929,
                "cost": 0.006976218931699979
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 2331753,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-searches",
            "absTime": 669587,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-searches-search",
                "type": "SearchNode",
                "absTime": 669587,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 453646,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 39723,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 371907,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 37102,
                        "count": 8,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 4896,
                        "count": 7,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 422929,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 30819,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 365452,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 26647,
                            "count": 8,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 38788,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 4229,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 30892,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 3658,
                                "count": 5,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 38788,
                            "cost": 0.0009564010049262492
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 14169,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 1783,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 9913,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 2465,
                                "count": 4,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 14169,
                            "cost": 0.00034936696500979754
                          }
                        ],
                        "relTime": 369972,
                        "cost": 0.009122450051422457
                      }
                    ],
                    "relTime": 30717,
                    "cost": 0.0007573932574074353
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 164892,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 148487,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 20733,
                            "properties": [],
                            "children": [],
                            "relTime": 20733,
                            "cost": 0.000511216408042073
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 94536,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 94536,
                            "cost": 0.002330987042428274
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 33218,
                        "cost": 0.0008190607554305493
                      }
                    ],
                    "relTime": 16405,
                    "cost": 0.0004045003218989151
                  }
                ],
                "relTime": 51049,
                "cost": 0.001258722153771272
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-aggrs",
            "absTime": 1230695,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 1230695,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 46559,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 31902,
                    "count": 7,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 1152225,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 235017,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 5893,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 206568,
                        "count": 7,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 22544,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 235017,
                    "cost": 0.005794846214673413
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20181220175545][3]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 793892,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 4482,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 767686,
                        "count": 7,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 21712,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 793892,
                    "cost": 0.019575103294908473
                  }
                ],
                "relTime": 201786,
                "cost": 0.004975464916470252
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 1900282,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-searches",
            "absTime": 691452,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-searches-search",
                "type": "SearchNode",
                "absTime": 691452,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 325007,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 34063,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 208675,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 71489,
                        "count": 16,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 10746,
                        "count": 15,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 280485,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 26216,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 201181,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 53069,
                            "count": 16,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 42257,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 5848,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 29495,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 6900,
                                "count": 10,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 42257,
                            "cost": 0.0010419366109407167
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 13515,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 1006,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 7481,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 5017,
                                "count": 7,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 13515,
                            "cost": 0.0003332411978338213
                          }
                        ],
                        "relTime": 224713,
                        "cost": 0.005540779081674545
                      }
                    ],
                    "relTime": 44522,
                    "cost": 0.0010977850247841207
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 299178,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 270851,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 42415,
                            "properties": [],
                            "children": [],
                            "relTime": 42415,
                            "cost": 0.0010458324384847598
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 189984,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 189984,
                            "cost": 0.0046844613932120385
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 38452,
                        "cost": 0.0009481162071110688
                      }
                    ],
                    "relTime": 28327,
                    "cost": 0.0006984627015196933
                  }
                ],
                "relTime": 67267,
                "cost": 0.0016586115911718575
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-aggrs",
            "absTime": 1993924,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 1993924,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 26994,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 82602,
                    "count": 15,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 1884311,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 440554,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 2656,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 387664,
                        "count": 15,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 50214,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 440554,
                    "cost": 0.010862800049610159
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190307172051][1]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 1228416,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 3077,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 1188067,
                        "count": 15,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 37252,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 1228416,
                    "cost": 0.030289220812299768
                  }
                ],
                "relTime": 324954,
                "cost": 0.008012435087006404
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 2685376,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-searches",
            "absTime": 539845,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-searches-search",
                "type": "SearchNode",
                "absTime": 539845,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 289317,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 43959,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 187854,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 51411,
                        "count": 9,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 6073,
                        "count": 8,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 254742,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 33434,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 181549,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 39747,
                            "count": 9,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 41508,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 3289,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 32737,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 5471,
                                "count": 7,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 41508,
                            "cost": 0.0010234684158110434
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 15163,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 2210,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 10403,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 2543,
                                "count": 3,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 15163,
                            "cost": 0.00037387615854637306
                          }
                        ],
                        "relTime": 198071,
                        "cost": 0.004883863654912527
                      }
                    ],
                    "relTime": 34575,
                    "cost": 0.0008525204894638824
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 190470,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 172423,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 26243,
                            "properties": [],
                            "children": [],
                            "relTime": 26243,
                            "cost": 0.0006470772293564906
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 117127,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 117127,
                            "cost": 0.002888016409817387
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 29053,
                        "cost": 0.0007163637825132082
                      }
                    ],
                    "relTime": 18047,
                    "cost": 0.0004449873397933387
                  }
                ],
                "relTime": 60058,
                "cost": 0.001480858295190798
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-aggrs",
            "absTime": 1624064,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 1624064,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 33855,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 52518,
                    "count": 8,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 1537681,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 294271,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 5093,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 252067,
                        "count": 8,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 37098,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 294271,
                    "cost": 0.0072558801722350285
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][1]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 1102580,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 3319,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 1064929,
                        "count": 8,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 34319,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 1102580,
                    "cost": 0.027186465401969267
                  }
                ],
                "relTime": 227213,
                "cost": 0.005602421922561304
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 2163909,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-searches",
            "absTime": 419805,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-searches-search",
                "type": "SearchNode",
                "absTime": 419805,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 212247,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 38323,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 126927,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 41861,
                        "count": 7,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 5120,
                        "count": 6,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 180884,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 28757,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 120046,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 32071,
                            "count": 7,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 26863,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 3216,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 18202,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 5435,
                                "count": 6,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 26863,
                            "cost": 0.000662364653896407
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 12504,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 1560,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 9183,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 1755,
                                "count": 2,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 12504,
                            "cost": 0.00030831283297921575
                          }
                        ],
                        "relTime": 141517,
                        "cost": 0.0034894039655086113
                      }
                    ],
                    "relTime": 31363,
                    "cost": 0.0007733217674925739
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 163062,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 147036,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 24891,
                            "properties": [],
                            "children": [],
                            "relTime": 24891,
                            "cost": 0.0006137407810049312
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 95994,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 95994,
                            "cost": 0.0023669371472334324
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 26151,
                        "cost": 0.0006448087728118579
                      }
                    ],
                    "relTime": 16026,
                    "cost": 0.0003951552672204824
                  }
                ],
                "relTime": 44496,
                "cost": 0.0010971439392388983
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-aggrs",
            "absTime": 1524955,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 1524955,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 595412,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 36655,
                    "count": 6,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 892880,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 211187,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 7507,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 158876,
                        "count": 6,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 44794,
                        "count": 3
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 211187,
                    "cost": 0.005207266655340822
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][2]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 575616,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 3002,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 550824,
                        "count": 6,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 21780,
                        "count": 3
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 575616,
                    "cost": 0.014193042199949157
                  }
                ],
                "relTime": 738152,
                "cost": 0.01820071451449729
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 1944760,
        "relTime": 0,
        "cost": 0
      },
      {
        "type": "ShardNode",
        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]",
        "properties": [],
        "children": [
          {
            "type": "SearchesNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-searches",
            "absTime": 866078,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-searches-search",
                "type": "SearchNode",
                "absTime": 866078,
                "properties": [],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "type": "BoostQuery",
                    "description": "(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0",
                    "absTime": 541057,
                    "properties": [
                      {
                        "name": "create weight",
                        "absTime": 33830,
                        "count": 1,
                        "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                      },
                      {
                        "name": "build scorer",
                        "absTime": 400534,
                        "count": 2,
                        "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                      },
                      {
                        "name": "next doc",
                        "absTime": 94175,
                        "count": 19,
                        "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                      },
                      {
                        "name": "advance",
                        "absTime": 0,
                        "count": 0,
                        "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                      },
                      {
                        "name": "match",
                        "absTime": 0,
                        "count": 0,
                        "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                      },
                      {
                        "name": "score",
                        "absTime": 12478,
                        "count": 18,
                        "help": "This records the time taken to score a particular document via its Scorer"
                      }
                    ],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "type": "BooleanQuery",
                        "description": "AddOn Feature:Audio Normalization AddOn Feature:Dolby",
                        "absTime": 489218,
                        "properties": [
                          {
                            "name": "create weight",
                            "absTime": 24710,
                            "count": 1,
                            "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                          },
                          {
                            "name": "build scorer",
                            "absTime": 394076,
                            "count": 2,
                            "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                          },
                          {
                            "name": "next doc",
                            "absTime": 70410,
                            "count": 19,
                            "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                          },
                          {
                            "name": "advance",
                            "absTime": 0,
                            "count": 0,
                            "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                          },
                          {
                            "name": "match",
                            "absTime": 0,
                            "count": 0,
                            "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                          },
                          {
                            "name": "score",
                            "absTime": 0,
                            "count": 0,
                            "help": "This records the time taken to score a particular document via its Scorer"
                          }
                        ],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Audio Normalization",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Audio Normalization",
                            "absTime": 38457,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 1925,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 29417,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 7101,
                                "count": 10,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 38457,
                            "cost": 0.0009482394927928424
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-searches-search-(ConstantScore(AddOn Feature:Audio Normalization AddOn Feature:Dolby))^0.0-AddOn Feature:Audio Normalization AddOn Feature:Dolby-AddOn Feature:Dolby",
                            "type": "TermQuery",
                            "description": "AddOn Feature:Dolby",
                            "absTime": 18880,
                            "properties": [
                              {
                                "name": "create weight",
                                "absTime": 1699,
                                "count": 1,
                                "help": "A Query in Lucene must be capable of reuse across multiple IndexSearchers (think of it as the engine that executes a search against a specific Lucene Index). This puts Lucene in a tricky spot, since many queries need to accumulate temporary state/statistics associated with the index it is being used against, but the Query contract mandates that it must be immutable. To get around this, Lucene asks each query to generate a Weight object which acts as a temporary context object to hold state associated with this particular (IndexSearcher, Query) tuple. The weight metric shows how long this process takes"
                              },
                              {
                                "name": "build scorer",
                                "absTime": 10217,
                                "count": 3,
                                "help": "This parameter shows how long it takes to build a Scorer for the query. A Scorer is the mechanism that iterates over matching documents and generates a score per-document (e.g. how well does \"foo\" match the document?). Note, this records the time required to generate the Scorer object, not actually score the documents. Some queries have faster or slower initialization of the Scorer, depending on optimizations, complexity, etc. This may also show timing associated with caching, if enabled and/or applicable for the query"
                              },
                              {
                                "name": "next doc",
                                "absTime": 6950,
                                "count": 10,
                                "help": "The Lucene method next_doc returns Doc ID of the next document matching the query. This statistic shows the time it takes to determine which document is the next match, a process that varies considerably depending on the nature of the query. Next_doc is a specialized form of advance() which is more convenient for many queries in Lucene. It is equivalent to advance(docId() + 1)"
                              },
                              {
                                "name": "advance",
                                "absTime": 0,
                                "count": 0,
                                "help": "advance is the \"lower level\" version of next_doc: it serves the same purpose of finding the next matching doc, but requires the calling query to perform extra tasks such as identifying and moving past skips, etc. However, not all queries can use next_doc, so advance is also timed for those queries. Conjunctions (e.g. must clauses in a boolean) are typical consumers of advance"
                              },
                              {
                                "name": "match",
                                "absTime": 0,
                                "count": 0,
                                "help": "Some queries, such as phrase queries, match documents using a \"two-phase\" process. First, the document is \"approximately\" matched, and if it matches approximately, it is checked a second time with a more rigorous (and expensive) process. The second phase verification is what the matches statistic measures. For example, a phrase query first checks a document approximately by ensuring all terms in the phrase are present in the doc. If all the terms are present, it then executes the second phase verification to ensure the terms are in-order to form the phrase, which is relatively more expensive than just checking for presence of the terms. Because this two-phase process is only used by a handful of queries, the metric statistic will often be zero"
                              },
                              {
                                "name": "score",
                                "absTime": 0,
                                "count": 0,
                                "help": "This records the time taken to score a particular document via its Scorer"
                              }
                            ],
                            "children": [],
                            "relTime": 18880,
                            "cost": 0.0004655267343768069
                          }
                        ],
                        "relTime": 431881,
                        "cost": 0.010648948706005813
                      }
                    ],
                    "relTime": 51839,
                    "cost": 0.001278201291491488
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-searches-search-search_cancelled",
                    "type": "CancellableCollector",
                    "description": "search_cancelled",
                    "absTime": 282762,
                    "properties": [],
                    "children": [
                      {
                        "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-searches-search-search_cancelled-search_multi",
                        "type": "MultiCollector",
                        "description": "search_multi",
                        "absTime": 244974,
                        "properties": [],
                        "children": [
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-searches-search-search_cancelled-search_multi-search_top_hits",
                            "type": "SimpleTopScoreDocCollector",
                            "description": "search_top_hits",
                            "absTime": 45767,
                            "properties": [],
                            "children": [],
                            "relTime": 45767,
                            "cost": 0.0011284831595457267
                          },
                          {
                            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-searches-search-search_cancelled-search_multi-aggregation",
                            "type": "ProfilingAggregator: [MeteredUnitCondition]",
                            "description": "aggregation",
                            "absTime": 148568,
                            "properties": [],
                            "children": [],
                            "help": "A collector that Elasticsearch uses to run aggregations against the query scope. A single aggregation collector is used to collect documents for all aggregations, so you will see a list of aggregations in the name rather.",
                            "relTime": 148568,
                            "cost": 0.0036632614339456274
                          }
                        ],
                        "help": "A collector that wraps several other collectors. This is seen when combinations of search, aggregations, global aggs, and post_filters are combined in a single search.",
                        "relTime": 50639,
                        "cost": 0.0012486127278658434
                      }
                    ],
                    "relTime": 37788,
                    "cost": 0.0009317438685715455
                  }
                ],
                "relTime": 42259,
                "cost": 0.001041985925213426
              }
            ],
            "relTime": 0,
            "cost": 0
          },
          {
            "type": "AggregationsNode",
            "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-aggrs",
            "absTime": 2123016,
            "properties": [],
            "children": [
              {
                "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-aggrs-MeteredUnitCondition",
                "type": "CompositeAggregator",
                "description": "MeteredUnitCondition",
                "absTime": 2123016,
                "properties": [
                  {
                    "name": "initialize",
                    "absTime": 26676,
                    "count": 1,
                    "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                  },
                  {
                    "name": "collect",
                    "absTime": 69831,
                    "count": 18,
                    "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                  },
                  {
                    "name": "build aggregation",
                    "absTime": 2026489,
                    "count": 1
                  },
                  {
                    "name": "reduce",
                    "absTime": 0,
                    "count": 0,
                    "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                  }
                ],
                "children": [
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-aggrs-MeteredUnitCondition-Location",
                    "type": "GlobalOrdinalsStringTermsAggregator",
                    "description": "Location",
                    "absTime": 453559,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 3833,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 394295,
                        "count": 18,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 55408,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 453559,
                    "cost": 0.01118346610790308
                  },
                  {
                    "nodeId": "detailedRootNode-shard-[V1Lm6aKHQ8mO2J-ujky32A][plc-elementalmediaconvert-usd-20190320213240][3]-aggrs-MeteredUnitCondition-Name",
                    "type": "StringTermsAggregator",
                    "description": "Name",
                    "absTime": 1346152,
                    "properties": [
                      {
                        "name": "initialize",
                        "absTime": 2971,
                        "count": 1,
                        "help": "This times how long it takes to create and initialise the aggregation before starting to collect documents."
                      },
                      {
                        "name": "collect",
                        "absTime": 1303587,
                        "count": 18,
                        "help": "This represents the cumulative time spent in the collect phase of the aggregation. This is where matching documents are passed to the aggregation and the state of the aggregator is updated based on the information contained in the documents."
                      },
                      {
                        "name": "build aggregation",
                        "absTime": 39571,
                        "count": 4
                      },
                      {
                        "name": "reduce",
                        "absTime": 0,
                        "count": 0,
                        "help": "This is not currently used and will always report 0. Currently aggregation profiling only times the shard level parts of the aggregation execution. Timing of the reduce phase will be added later."
                      }
                    ],
                    "children": [],
                    "relTime": 1346152,
                    "cost": 0.03319225341815717
                  }
                ],
                "relTime": 323305,
                "cost": 0.007971775469157498
              }
            ],
            "relTime": 0,
            "cost": 0
          }
        ],
        "absTime": 2989094,
        "relTime": 0,
        "cost": 0
      }
    ],
    "absTime": 40556210,
    "relTime": 0,
    "cost": 0
  },
  "combinedRootNode": {
    "type": "RootNode",
    "nodeId": "combinedRootNode",
    "properties": [],
    "children": [],
    "absTime": 0,
    "relTime": 0,
    "cost": 0
  }
}